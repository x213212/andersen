// This file generated by ngrestcg
// For more information, please visit: https://github.com/loentar/ngrest
// DO NOT EDIT. ANY CHANGES WILL BE LOST

#include <ngrest/utils/Log.h>
#include <ngrest/utils/fromcstring.h>
#include <ngrest/utils/tostring.h>
#include <ngrest/utils/Exception.h>
#include <ngrest/common/ObjectModel.h>
#include <ngrest/common/ObjectModelUtils.h>
#include <ngrest/common/Message.h>
#include <ngrest/common/HttpMethod.h>
#include <ngrest/common/Service.h>
#include <ngrest/engine/ServiceDescription.h>
#include "TestServiceWrapper.h"

namespace ngrest {


// enum ValType

const char* ValTypeSerializer::toCString(ValType value)
{
    switch (value) {
    case ValType::Zero:
        return "Zero";
    case ValType::One:
        return "One";
    case ValType::Two:
        return "Two";
    default:
        NGREST_THROW_ASSERT("Can't serialize enum ValType from value: [" + ::ngrest::toString(static_cast<int>(value)) + "]");
    }
}

ValType ValTypeSerializer::fromCString(const char* str)
{
    if (!strcmp(str, "Zero"))
        return ValType::Zero;
    if (!strcmp(str, "One"))
        return ValType::One;
    if (!strcmp(str, "Two"))
        return ValType::Two;
    NGREST_THROW_ASSERT("Can't deserialize enum ValType from value: [" + std::string(str) + "]");
}


// typedef TestTypedef

void TestTypedefSerializer::serialize(::ngrest::MessageContext* context, const TestTypedef&value, ::ngrest::Node*& node)
{
// SERIALIZE : ::ngrest::Test struct
    node = context->pool->alloc< ::ngrest::Object>();
    ::ngrest::TestSerializer::serialize(context, value, node);
// END SERIALIZE: ::ngrest::Test struct
}

void TestTypedefSerializer::deserialize(const ::ngrest::Node* node, TestTypedef& value)
{
// DESERIALIZE: ::ngrest::Test struct
    ::ngrest::TestSerializer::deserialize(node, value);
// END DESERIALIZE: ::ngrest::Test struct
}


// typedef StringMap

void StringMapSerializer::serialize(::ngrest::MessageContext* context, const StringMap&value, ::ngrest::Node*& node)
{
// SERIALIZE : std::map<std::string, std::string> template
// count = 2
    ::ngrest::Object* valueObj = context->pool->alloc< ::ngrest::Object>();
    node = valueObj;
    ::ngrest::NamedNode* valueObjItemLast = nullptr;
    for (const auto& valueItem : value) {
        ::ngrest::NamedNode* valueObjItem = context->pool->alloc< ::ngrest::NamedNode>(valueItem.first.c_str());
        if (valueObjItemLast == nullptr) {
            valueObj->firstChild = valueObjItem;
        } else {
            valueObjItemLast->nextSibling = valueObjItem;
        }
        valueObjItemLast = valueObjItem;

    // SERIALIZE : std::string string
        valueObjItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, valueItem.second.c_str());
    // END SERIALIZE: std::string string
    }
// END SERIALIZE: std::map<std::string, std::string> template
}

void StringMapSerializer::deserialize(const ::ngrest::Node* node, StringMap& value)
{
// DESERIALIZE: std::map<std::string, std::string> template
    NGREST_ASSERT_NULL(node);
    NGREST_ASSERT(node->type == ::ngrest::NodeType::Object, "Object node expected");
    // count = 2 / map / value / value / static_cast<const ::ngrest::Object*>(node)
    for (const ::ngrest::NamedNode* valueChild = static_cast<const ::ngrest::Object*>(node)->firstChild; valueChild; valueChild = valueChild->nextSibling) {
        NGREST_ASSERT_NULL(valueChild->name);
        // deserialize key

        std::string& valueValue = value[valueChild->name];
        // deserialize value
    // DESERIALIZE: std::string string
        ::ngrest::ObjectModelUtils::getValue(valueChild->node, valueValue);
    // END DESERIALIZE: std::string string
    } // for(NamedNode...
// END DESERIALIZE: std::map<std::string, std::string> template
}


// typedef StringList

void StringListSerializer::serialize(::ngrest::MessageContext* context, const StringList&value, ::ngrest::Node*& node)
{
// SERIALIZE : std::list<std::string> template
// count = 1
    ::ngrest::Array* valueArray = context->pool->alloc< ::ngrest::Array>();
    node = valueArray;
    ::ngrest::LinkedNode* valueArrayItemLast = nullptr;
    for (const auto& valueItem : value) {
        ::ngrest::LinkedNode* valueArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
        if (valueArrayItemLast == nullptr) {
            valueArray->firstChild = valueArrayItem;
        } else {
            valueArrayItemLast->nextSibling = valueArrayItem;
        }
        valueArrayItemLast = valueArrayItem;
    // SERIALIZE : std::string string
        valueArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, valueItem.c_str());
    // END SERIALIZE: std::string string
    }
// END SERIALIZE: std::list<std::string> template
}

void StringListSerializer::deserialize(const ::ngrest::Node* node, StringList& value)
{
// DESERIALIZE: std::list<std::string> template
    NGREST_ASSERT_NULL(node);
    NGREST_ASSERT(node->type == ::ngrest::NodeType::Array, "Array node expected");
    // count = 1 / list / value / value / static_cast<const ::ngrest::Array*>(node)
    for (const ::ngrest::LinkedNode* valueChild = static_cast<const ::ngrest::Array*>(node)->firstChild; valueChild; valueChild = valueChild->nextSibling) {
        value.push_back(std::string());
        std::string& valueItem = value.back();
    // DESERIALIZE: std::string string
        ::ngrest::ObjectModelUtils::getValue(valueChild->node, valueItem);
    // END DESERIALIZE: std::string string
    }
// END DESERIALIZE: std::list<std::string> template
}


// struct Test

void ::ngrest::TestSerializer::serialize(::ngrest::MessageContext* context, const Test& value, ::ngrest::Node* node)
{
    ::ngrest::NamedNode* oldFirstChildNode = static_cast< ::ngrest::Object*>(node)->firstChild;
    ::ngrest::NamedNode* aNode = context->pool->alloc< ::ngrest::NamedNode>("a");
    static_cast< ::ngrest::Object*>(node)->firstChild = aNode;
// SERIALIZE : int generic
    char aBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
    NGREST_ASSERT(::ngrest::toCString(value.a, aBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
    const char* aCStr = context->pool->putCString(aBuff, true);
    aNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, aCStr);
// END SERIALIZE: int generic
    ::ngrest::NamedNode* bNode = context->pool->alloc< ::ngrest::NamedNode>("b");
    aNode->nextSibling = bNode;
// SERIALIZE : std::string string
    bNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, value.b.c_str());
// END SERIALIZE: std::string string
    ::ngrest::NamedNode* testEnumNode = context->pool->alloc< ::ngrest::NamedNode>("testEnum");
    bNode->nextSibling = testEnumNode;
// SERIALIZE : ::ngrest::Test::TestEnum enum
    testEnumNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, ::ngrest::TestSerializer::TestEnumSerializer::toCString(value.testEnum));
// END SERIALIZE: ::ngrest::Test::TestEnum enum
    ::ngrest::NamedNode* nNode = context->pool->alloc< ::ngrest::NamedNode>("n");
    testEnumNode->nextSibling = nNode;
// SERIALIZE : ::ngrest::Test::Nested struct
    nNode->node = context->pool->alloc< ::ngrest::Object>();
    ::ngrest::TestSerializer::NestedSerializer::serialize(context, value.n, nNode->node);
// END SERIALIZE: ::ngrest::Test::Nested struct
    ::ngrest::NamedNode* lsNode = context->pool->alloc< ::ngrest::NamedNode>("ls");
    nNode->nextSibling = lsNode;
// SERIALIZE : std::list<std::string> template
// count = 1
    ::ngrest::Array* lsArray = context->pool->alloc< ::ngrest::Array>();
    lsNode->node = lsArray;
    ::ngrest::LinkedNode* lsArrayItemLast = nullptr;
    for (const auto& lsItem : value.ls) {
        ::ngrest::LinkedNode* lsArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
        if (lsArrayItemLast == nullptr) {
            lsArray->firstChild = lsArrayItem;
        } else {
            lsArrayItemLast->nextSibling = lsArrayItem;
        }
        lsArrayItemLast = lsArrayItem;
    // SERIALIZE : std::string string
        lsArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, lsItem.c_str());
    // END SERIALIZE: std::string string
    }
// END SERIALIZE: std::list<std::string> template
    lsNode->nextSibling = oldFirstChildNode;
}

void ::ngrest::TestSerializer::deserialize(const ::ngrest::Node* node, Test& value)
{
    NGREST_ASSERT(node->type == ::ngrest::NodeType::Object, "Unexpected node type while deserializing ::ngrest::Test");
    const ::ngrest::Object* object = static_cast<const ::ngrest::Object*>(node);
    ::ngrest::ObjectModelUtils::getChildValue(object, "a", value.a);
    ::ngrest::ObjectModelUtils::getChildValue(object, "b", value.b);
    value.testEnum = ::ngrest::TestSerializer::TestEnumSerializer::fromCString(::ngrest::ObjectModelUtils::getChildValue(object, "testEnum"));
    const ::ngrest::Object* nObject = static_cast<const ::ngrest::Object*>(::ngrest::ObjectModelUtils::getNamedChild(object, "n", ::ngrest::NodeType::Object)->node);
// DESERIALIZE: ::ngrest::Test::Nested struct
    ::ngrest::TestSerializer::NestedSerializer::deserialize(nObject, value.n);
// END DESERIALIZE: ::ngrest::Test::Nested struct
    const ::ngrest::Array* lsArray = static_cast<const ::ngrest::Array*>(::ngrest::ObjectModelUtils::getNamedChild(object, "ls", ::ngrest::NodeType::Array)->node);
// DESERIALIZE: std::list<std::string> template
    NGREST_ASSERT_NULL(lsArray);
    NGREST_ASSERT(lsArray->type == ::ngrest::NodeType::Array, "Array node expected");
    // count = 1 / list / value.ls / ls / static_cast<const ::ngrest::Array*>(lsArray)
    for (const ::ngrest::LinkedNode* lsChild = static_cast<const ::ngrest::Array*>(lsArray)->firstChild; lsChild; lsChild = lsChild->nextSibling) {
        value.ls.push_back(std::string());
        std::string& lsItem = value.ls.back();
    // DESERIALIZE: std::string string
        ::ngrest::ObjectModelUtils::getValue(lsChild->node, lsItem);
    // END DESERIALIZE: std::string string
    }
// END DESERIALIZE: std::list<std::string> template
}


// struct Test::Nested

void ::ngrest::TestSerializer::NestedSerializer::serialize(::ngrest::MessageContext* context, const Test::Nested& value, ::ngrest::Node* node)
{
    ::ngrest::NamedNode* oldFirstChildNode = static_cast< ::ngrest::Object*>(node)->firstChild;
    ::ngrest::NamedNode* bNode = context->pool->alloc< ::ngrest::NamedNode>("b");
    static_cast< ::ngrest::Object*>(node)->firstChild = bNode;
// SERIALIZE : bool generic
    bNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Boolean, value.b ? "true" : "false");
// END SERIALIZE: bool generic
    bNode->nextSibling = oldFirstChildNode;
}

void ::ngrest::TestSerializer::NestedSerializer::deserialize(const ::ngrest::Node* node, Test::Nested& value)
{
    NGREST_ASSERT(node->type == ::ngrest::NodeType::Object, "Unexpected node type while deserializing ::ngrest::Test::Nested");
    const ::ngrest::Object* object = static_cast<const ::ngrest::Object*>(node);
    ::ngrest::ObjectModelUtils::getChildValue(object, "b", value.b);
}





// enum TestEnum

const char* TestSerializer::TestEnumSerializer::toCString(Test::TestEnum value)
{
    switch (value) {
    case Test::TestEnum::Some:
        return "Some";
    case Test::TestEnum::Values:
        return "Values";
    case Test::TestEnum::Here:
        return "Here";
    default:
        NGREST_THROW_ASSERT("Can't serialize enum TestEnum from value: [" + ::ngrest::toString(static_cast<int>(value)) + "]");
    }
}

Test::TestEnum TestSerializer::TestEnumSerializer::fromCString(const char* str)
{
    if (!strcmp(str, "Some"))
        return Test::TestEnum::Some;
    if (!strcmp(str, "Values"))
        return Test::TestEnum::Values;
    if (!strcmp(str, "Here"))
        return Test::TestEnum::Here;
    NGREST_THROW_ASSERT("Can't deserialize enum TestEnum from value: [" + std::string(str) + "]");
}



// struct TestChild

void ::ngrest::TestChildSerializer::serialize(::ngrest::MessageContext* context, const TestChild& value, ::ngrest::Node* node)
{
    // serialize parent struct
    ::ngrest::TestSerializer::serialize(context, value, node);

    ::ngrest::NamedNode* oldFirstChildNode = static_cast< ::ngrest::Object*>(node)->firstChild;
    ::ngrest::NamedNode* isSomethingNode = context->pool->alloc< ::ngrest::NamedNode>("isSomething");
    static_cast< ::ngrest::Object*>(node)->firstChild = isSomethingNode;
// SERIALIZE : bool generic
    isSomethingNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Boolean, value.isSomething ? "true" : "false");
// END SERIALIZE: bool generic
    isSomethingNode->nextSibling = oldFirstChildNode;
}

void ::ngrest::TestChildSerializer::deserialize(const ::ngrest::Node* node, TestChild& value)
{
    NGREST_ASSERT(node->type == ::ngrest::NodeType::Object, "Unexpected node type while deserializing ::ngrest::TestChild");
    const ::ngrest::Object* object = static_cast<const ::ngrest::Object*>(node);
    // deserialize parent struct
    ::ngrest::TestSerializer::deserialize(node, value);

    ::ngrest::ObjectModelUtils::getChildValue(object, "isSomething", value.isSomething);
}




// struct TestPtr

void ::ngrest::TestPtrSerializer::serialize(::ngrest::MessageContext* context, const TestPtr& value, ::ngrest::Node* node)
{
    ::ngrest::NamedNode* oldFirstChildNode = static_cast< ::ngrest::Object*>(node)->firstChild;
    ::ngrest::NamedNode* intValueNode = context->pool->alloc< ::ngrest::NamedNode>("intValue");
    static_cast< ::ngrest::Object*>(node)->firstChild = intValueNode;
// SERIALIZE : ngrest::Nullable<int> template
// count = 1
    if (value.intValue.isValid()) {
    // SERIALIZE : int generic
        char intValueBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
        NGREST_ASSERT(::ngrest::toCString((*value.intValue), intValueBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
        const char* intValueCStr = context->pool->putCString(intValueBuff, true);
        intValueNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, intValueCStr);
    // END SERIALIZE: int generic
    }
// END SERIALIZE: ngrest::Nullable<int> template
    ::ngrest::NamedNode* enumValueNode = context->pool->alloc< ::ngrest::NamedNode>("enumValue");
    intValueNode->nextSibling = enumValueNode;
// SERIALIZE : ngrest::Nullable< ::ngrest::ValType > template
// count = 1
    if (value.enumValue.isValid()) {
    // SERIALIZE : ::ngrest::ValType enum
        enumValueNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, ::ngrest::ValTypeSerializer::toCString((*value.enumValue)));
    // END SERIALIZE: ::ngrest::ValType enum
    }
// END SERIALIZE: ngrest::Nullable< ::ngrest::ValType > template
    ::ngrest::NamedNode* strValueNode = context->pool->alloc< ::ngrest::NamedNode>("strValue");
    enumValueNode->nextSibling = strValueNode;
// SERIALIZE : ngrest::Nullable<std::string> template
// count = 1
    if (value.strValue.isValid()) {
    // SERIALIZE : std::string string
        strValueNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, (*value.strValue).c_str());
    // END SERIALIZE: std::string string
    }
// END SERIALIZE: ngrest::Nullable<std::string> template
    ::ngrest::NamedNode* structValueNode = context->pool->alloc< ::ngrest::NamedNode>("structValue");
    strValueNode->nextSibling = structValueNode;
// SERIALIZE : ngrest::Nullable< ::ngrest::Test > template
// count = 1
    if (value.structValue.isValid()) {
    // SERIALIZE : ::ngrest::Test struct
        structValueNode->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::TestSerializer::serialize(context, (*value.structValue), structValueNode->node);
    // END SERIALIZE: ::ngrest::Test struct
    }
// END SERIALIZE: ngrest::Nullable< ::ngrest::Test > template
    ::ngrest::NamedNode* listValueNode = context->pool->alloc< ::ngrest::NamedNode>("listValue");
    structValueNode->nextSibling = listValueNode;
// SERIALIZE : ngrest::Nullable< std::list<std::string> > template
// count = 1
    if (value.listValue.isValid()) {
    // SERIALIZE : std::list<std::string> template
    // count = 1
        ::ngrest::Array* listValueArray = context->pool->alloc< ::ngrest::Array>();
        listValueNode->node = listValueArray;
        ::ngrest::LinkedNode* listValueArrayItemLast = nullptr;
        for (const auto& listValueItem : (*value.listValue)) {
            ::ngrest::LinkedNode* listValueArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (listValueArrayItemLast == nullptr) {
                listValueArray->firstChild = listValueArrayItem;
            } else {
                listValueArrayItemLast->nextSibling = listValueArrayItem;
            }
            listValueArrayItemLast = listValueArrayItem;
        // SERIALIZE : std::string string
            listValueArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, listValueItem.c_str());
        // END SERIALIZE: std::string string
        }
    // END SERIALIZE: std::list<std::string> template
    }
// END SERIALIZE: ngrest::Nullable< std::list<std::string> > template
    ::ngrest::NamedNode* mapValueNode = context->pool->alloc< ::ngrest::NamedNode>("mapValue");
    listValueNode->nextSibling = mapValueNode;
// SERIALIZE : ngrest::Nullable< std::map<int, std::string> > template
// count = 1
    if (value.mapValue.isValid()) {
    // SERIALIZE : std::map<int, std::string> template
    // count = 2
        ::ngrest::Object* mapValueObj = context->pool->alloc< ::ngrest::Object>();
        mapValueNode->node = mapValueObj;
        ::ngrest::NamedNode* mapValueObjItemLast = nullptr;
        for (const auto& mapValueItem : (*value.mapValue)) {
        char mapValueBuffItem[NGREST_NUM_TO_STR_BUFF_SIZE];
        NGREST_ASSERT(::ngrest::toCString(mapValueItem.first, mapValueBuffItem, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize std::map<int, std::string>");
        const char* mapValueCStrItem = context->pool->putCString(mapValueBuffItem, true);
            ::ngrest::NamedNode* mapValueObjItem = context->pool->alloc< ::ngrest::NamedNode>(mapValueCStrItem);
            if (mapValueObjItemLast == nullptr) {
                mapValueObj->firstChild = mapValueObjItem;
            } else {
                mapValueObjItemLast->nextSibling = mapValueObjItem;
            }
            mapValueObjItemLast = mapValueObjItem;

        // SERIALIZE : std::string string
            mapValueObjItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, mapValueItem.second.c_str());
        // END SERIALIZE: std::string string
        }
    // END SERIALIZE: std::map<int, std::string> template
    }
// END SERIALIZE: ngrest::Nullable< std::map<int, std::string> > template
    mapValueNode->nextSibling = oldFirstChildNode;
}

void ::ngrest::TestPtrSerializer::deserialize(const ::ngrest::Node* node, TestPtr& value)
{
    NGREST_ASSERT(node->type == ::ngrest::NodeType::Object, "Unexpected node type while deserializing ::ngrest::TestPtr");
    const ::ngrest::Object* object = static_cast<const ::ngrest::Object*>(node);
    const ::ngrest::NamedNode* namedNodeintValue = object->findChildByName("intValue");
    if (namedNodeintValue != nullptr) {
    // DESERIALIZE: ngrest::Nullable<int> template
        if (namedNodeintValue->node != nullptr) {
        // DESERIALIZE: int generic
            ::ngrest::ObjectModelUtils::getValue(namedNodeintValue->node, value.intValue.get());
        // END DESERIALIZE: int generic
        }
        // count = 1 / Nullable / value.intValue / intValue / namedNodeintValue->node
    // END DESERIALIZE: ngrest::Nullable<int> template
    }
    const ::ngrest::NamedNode* namedNodeenumValue = object->findChildByName("enumValue");
    if (namedNodeenumValue != nullptr) {
    // DESERIALIZE: ngrest::Nullable< ::ngrest::ValType > template
        if (namedNodeenumValue->node != nullptr) {
        // DESERIALIZE: ::ngrest::ValType enum
            value.enumValue.get() = ::ngrest::ValTypeSerializer::fromCString(::ngrest::ObjectModelUtils::getValue(namedNodeenumValue->node));
        // END DESERIALIZE: ::ngrest::ValType enum
        }
        // count = 1 / Nullable / value.enumValue / enumValue / namedNodeenumValue->node
    // END DESERIALIZE: ngrest::Nullable< ::ngrest::ValType > template
    }
    const ::ngrest::NamedNode* namedNodestrValue = object->findChildByName("strValue");
    if (namedNodestrValue != nullptr) {
    // DESERIALIZE: ngrest::Nullable<std::string> template
        if (namedNodestrValue->node != nullptr) {
        // DESERIALIZE: std::string string
            ::ngrest::ObjectModelUtils::getValue(namedNodestrValue->node, value.strValue.get());
        // END DESERIALIZE: std::string string
        }
        // count = 1 / Nullable / value.strValue / strValue / namedNodestrValue->node
    // END DESERIALIZE: ngrest::Nullable<std::string> template
    }
    const ::ngrest::NamedNode* namedNodestructValue = object->findChildByName("structValue");
    if (namedNodestructValue != nullptr) {
    // DESERIALIZE: ngrest::Nullable< ::ngrest::Test > template
        if (namedNodestructValue->node != nullptr) {
        // DESERIALIZE: ::ngrest::Test struct
            ::ngrest::TestSerializer::deserialize(namedNodestructValue->node, value.structValue.get());
        // END DESERIALIZE: ::ngrest::Test struct
        }
        // count = 1 / Nullable / value.structValue / structValue / namedNodestructValue->node
    // END DESERIALIZE: ngrest::Nullable< ::ngrest::Test > template
    }
    const ::ngrest::NamedNode* namedNodelistValue = object->findChildByName("listValue");
    if (namedNodelistValue != nullptr) {
    // DESERIALIZE: ngrest::Nullable< std::list<std::string> > template
        if (namedNodelistValue->node != nullptr) {
        std::list<std::string>& value_listValuelist = value.listValue.get();
        // DESERIALIZE: std::list<std::string> template
            NGREST_ASSERT_NULL(namedNodelistValue->node);
            NGREST_ASSERT(namedNodelistValue->node->type == ::ngrest::NodeType::Array, "Array node expected");
            // count = 1 / list / value_listValuelist / listValue / static_cast<const ::ngrest::Array*>(namedNodelistValue->node)
            for (const ::ngrest::LinkedNode* listValueChild = static_cast<const ::ngrest::Array*>(namedNodelistValue->node)->firstChild; listValueChild; listValueChild = listValueChild->nextSibling) {
                value_listValuelist.push_back(std::string());
                std::string& listValueItem = value_listValuelist.back();
            // DESERIALIZE: std::string string
                ::ngrest::ObjectModelUtils::getValue(listValueChild->node, listValueItem);
            // END DESERIALIZE: std::string string
            }
        // END DESERIALIZE: std::list<std::string> template
        }
        // count = 1 / Nullable / value.listValue / listValue / namedNodelistValue->node
    // END DESERIALIZE: ngrest::Nullable< std::list<std::string> > template
    }
    const ::ngrest::NamedNode* namedNodemapValue = object->findChildByName("mapValue");
    if (namedNodemapValue != nullptr) {
    // DESERIALIZE: ngrest::Nullable< std::map<int, std::string> > template
        if (namedNodemapValue->node != nullptr) {
        std::map<int, std::string>& value_mapValuemap = value.mapValue.get();
        // DESERIALIZE: std::map<int, std::string> template
            NGREST_ASSERT_NULL(namedNodemapValue->node);
            NGREST_ASSERT(namedNodemapValue->node->type == ::ngrest::NodeType::Object, "Object node expected");
            // count = 2 / map / value_mapValuemap / mapValue / static_cast<const ::ngrest::Object*>(namedNodemapValue->node)
            for (const ::ngrest::NamedNode* mapValueChild = static_cast<const ::ngrest::Object*>(namedNodemapValue->node)->firstChild; mapValueChild; mapValueChild = mapValueChild->nextSibling) {
                NGREST_ASSERT_NULL(mapValueChild->name);
                // deserialize key
                int mapValueKey;
                NGREST_ASSERT(::ngrest::fromCString(mapValueChild->name, mapValueKey), "Cannot deserialize key of value_mapValuemap");

                std::string& mapValueValue = value_mapValuemap[mapValueKey];
                // deserialize value
            // DESERIALIZE: std::string string
                ::ngrest::ObjectModelUtils::getValue(mapValueChild->node, mapValueValue);
            // END DESERIALIZE: std::string string
            } // for(NamedNode...
        // END DESERIALIZE: std::map<int, std::string> template
        }
        // count = 1 / Nullable / value.mapValue / mapValue / namedNodemapValue->node
    // END DESERIALIZE: ngrest::Nullable< std::map<int, std::string> > template
    }
}






TestServiceWrapper::TestServiceWrapper():
    service(new TestService())
{
}

TestServiceWrapper::~TestServiceWrapper()
{
    delete service;
}


::ngrest::Service* TestServiceWrapper::getServiceImpl()
{
    return service;
}

void TestServiceWrapper::invoke(const ::ngrest::OperationDescription* operation, ::ngrest::MessageContext* context)
{
    if (operation->name == "get") {   //  **************** get *****************

        /// bool get();

        bool result = service->get();

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Boolean, result ? "true" : "false");

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "echoSync") {   //  **************** echoSync *****************

        /// std::string echoSync(const std::string& value);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/echoSync");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::string value;

        ::ngrest::ObjectModelUtils::getChildValue(request, "value", value);
/// ######### deserialize request end ###########

        const std::string& result = service->echoSync(value);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("resultValue");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, result.c_str());

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "echoASync") {   //  **************** echoASync *****************

        /// void echoASync(const std::string& value, ngrest::Callback<const std::string&>& callback);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/echoASync");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::string value;

        ::ngrest::ObjectModelUtils::getChildValue(request, "value", value);
        // count = 1
/// ######### deserialize request end ###########


        class Callback_echoASync: public ::ngrest::Callback< const std::string& >
        {
        public:
            Callback_echoASync(::ngrest::MessageContext* context_):
                context(context_)
            {
            }

            void success(const std::string& result) override
            {
        /// ######### serialize response ###########

                ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
                ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
                responseNode->firstChild = resultNode;

                resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, result.c_str());

                context->response->node = responseNode;
        /// ######### serialize response end ###########

                context->callback->success();
                // no need to "delete this" - it's in mempool
            }

            virtual void error(const ::ngrest::Exception& error) override
            {
                context->callback->error(error);
                // no need to "delete this" - it's in mempool
            }

            ::ngrest::MessageContext* const context;
        };

        service->echoASync(value, *context->pool->alloc<Callback_echoASync>(context));

    } else if (operation->name == "largeResponse") {   //  **************** largeResponse *****************

        /// std::string largeResponse();

        const std::string& result = service->largeResponse();

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, result.c_str());

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "add") {   //  **************** add *****************

        /// int add(int a, int b);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/add");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        int a;
        int b;

        ::ngrest::ObjectModelUtils::getChildValue(request, "a", a);
        ::ngrest::ObjectModelUtils::getChildValue(request, "b", b);
/// ######### deserialize request end ###########

        int result = service->add(a, b);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        char resultBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
        NGREST_ASSERT(::ngrest::toCString(result, resultBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize result for TestService/add");
        const char* resultCStr = context->pool->putCString(resultBuff, true);
        resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultCStr);

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "set") {   //  **************** set *****************

        /// void set(bool val);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/set");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        bool val;

        ::ngrest::ObjectModelUtils::getChildValue(request, "val", val);
/// ######### deserialize request end ###########

        service->set(val);

        context->callback->success();
    } else if (operation->name == "notify") {   //  **************** notify *****************

        /// void notify();

        service->notify();

        context->callback->success();
    } else if (operation->name == "test") {   //  **************** test *****************

        /// ::ngrest::Test test(const Test& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/test");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::Test arg;

        const ::ngrest::NamedNode* argObj = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Object);
        ::ngrest::TestSerializer::deserialize(argObj->node, arg);
/// ######### deserialize request end ###########

        const ::ngrest::Test& result = service->test(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::TestSerializer::serialize(context, result, resultNode->node);

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListStr") {   //  **************** templListStr *****************

        /// std::list<std::string> templListStr(const std::list<std::string>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListStr");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list<std::string> arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            arg.push_back(std::string());
            std::string& argItem = arg.back();
        // DESERIALIZE: std::string string
            ::ngrest::ObjectModelUtils::getValue(argChild->node, argItem);
        // END DESERIALIZE: std::string string
        }
/// ######### deserialize request end ###########

        const std::list<std::string>& result = service->templListStr(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        resultNode->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : std::string string
            resultArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, it.c_str());
        // END SERIALIZE: std::string string
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templList") {   //  **************** templList *****************

        /// std::list<int> templList(const std::list<int>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templList");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list<int> arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            int argItem;
        // DESERIALIZE: int generic
            ::ngrest::ObjectModelUtils::getValue(argChild->node, argItem);
        // END DESERIALIZE: int generic
            arg.push_back(argItem);
        }
/// ######### deserialize request end ###########

        const std::list<int>& result = service->templList(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        resultNode->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : int generic
            char resultItemBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
            NGREST_ASSERT(::ngrest::toCString(it, resultItemBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
            const char* resultItemCStr = context->pool->putCString(resultItemBuff, true);
            resultArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultItemCStr);
        // END SERIALIZE: int generic
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templVector") {   //  **************** templVector *****************

        /// std::vector<int> templVector(const std::vector<int>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templVector");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::vector<int> arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            int argItem;
        // DESERIALIZE: int generic
            ::ngrest::ObjectModelUtils::getValue(argChild->node, argItem);
        // END DESERIALIZE: int generic
            arg.push_back(argItem);
        }
/// ######### deserialize request end ###########

        const std::vector<int>& result = service->templVector(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        resultNode->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : int generic
            char resultItemBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
            NGREST_ASSERT(::ngrest::toCString(it, resultItemBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
            const char* resultItemCStr = context->pool->putCString(resultItemBuff, true);
            resultArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultItemCStr);
        // END SERIALIZE: int generic
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListOfStruct") {   //  **************** templListOfStruct *****************

        /// std::list< ::ngrest::Test > templListOfStruct(const std::list<Test>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListOfStruct");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list< ::ngrest::Test > arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            arg.push_back(::ngrest::Test());
            ::ngrest::Test& argItem = arg.back();
        // DESERIALIZE: ::ngrest::Test struct
            ::ngrest::TestSerializer::deserialize(argChild->node, argItem);
        // END DESERIALIZE: ::ngrest::Test struct
        }
/// ######### deserialize request end ###########

        const std::list< ::ngrest::Test >& result = service->templListOfStruct(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        resultNode->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : ::ngrest::Test struct
            resultArrayItem->node = context->pool->alloc< ::ngrest::Object>();
            ::ngrest::TestSerializer::serialize(context, it, resultArrayItem->node);
        // END SERIALIZE: ::ngrest::Test struct
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListOfTypedef") {   //  **************** templListOfTypedef *****************

        /// std::list< ::ngrest::TestTypedef > templListOfTypedef(const std::list< ::ngrest::TestTypedef >& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListOfTypedef");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list< ::ngrest::TestTypedef > arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            arg.push_back(::ngrest::TestTypedef());
            ::ngrest::TestTypedef& argItem = arg.back();
        // DESERIALIZE: ::ngrest::TestTypedef typedef
            ::ngrest::TestTypedefSerializer::deserialize(argChild->node, argItem);
        // END DESERIALIZE: ::ngrest::TestTypedef typedef
        }
/// ######### deserialize request end ###########

        const std::list< ::ngrest::TestTypedef >& result = service->templListOfTypedef(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        resultNode->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : ::ngrest::TestTypedef typedef
            resultArrayItem->node = context->pool->alloc< ::ngrest::Object>();
            ::ngrest::TestTypedefSerializer::serialize(context, it, resultArrayItem->node);
        // END SERIALIZE: ::ngrest::TestTypedef typedef
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListOfTypedefList") {   //  **************** templListOfTypedefList *****************

        /// ::ngrest::StringList templListOfTypedefList(const ::ngrest::StringList& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListOfTypedefList");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::StringList arg;

        const ::ngrest::NamedNode* argObj = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg");
        ::ngrest::StringListSerializer::deserialize(argObj->node, arg);
/// ######### deserialize request end ###########

        const ::ngrest::StringList& result = service->templListOfTypedefList(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::StringListSerializer::serialize(context, result, resultNode->node);

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListList") {   //  **************** templListList *****************

        /// std::list< std::list<int> > templListList(const std::list< std::list<int> >& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListList");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list< std::list<int> > arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            arg.push_back(std::list<int>());
            std::list<int>& argItem = arg.back();
        // DESERIALIZE: std::list<int> template
            NGREST_ASSERT_NULL(argChild->node);
            NGREST_ASSERT(argChild->node->type == ::ngrest::NodeType::Array, "Array node expected");
            // count = 1 / list / argItem / argItem / static_cast<const ::ngrest::Array*>(argChild->node)
            for (const ::ngrest::LinkedNode* argItemChild = static_cast<const ::ngrest::Array*>(argChild->node)->firstChild; argItemChild; argItemChild = argItemChild->nextSibling) {
                int argItemItem;
            // DESERIALIZE: int generic
                ::ngrest::ObjectModelUtils::getValue(argItemChild->node, argItemItem);
            // END DESERIALIZE: int generic
                argItem.push_back(argItemItem);
            }
        // END DESERIALIZE: std::list<int> template
        }
/// ######### deserialize request end ###########

        const std::list< std::list<int> >& result = service->templListList(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        resultNode->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : std::list<int> template
        // count = 1
            ::ngrest::Array* resultItemArray = context->pool->alloc< ::ngrest::Array>();
            resultArrayItem->node = resultItemArray;
            ::ngrest::LinkedNode* resultItemArrayItemLast = nullptr;
            for (const auto& resultItemItem : it) {
                ::ngrest::LinkedNode* resultItemArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
                if (resultItemArrayItemLast == nullptr) {
                    resultItemArray->firstChild = resultItemArrayItem;
                } else {
                    resultItemArrayItemLast->nextSibling = resultItemArrayItem;
                }
                resultItemArrayItemLast = resultItemArrayItem;
            // SERIALIZE : int generic
                char resultItemItemBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
                NGREST_ASSERT(::ngrest::toCString(resultItemItem, resultItemItemBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
                const char* resultItemItemCStr = context->pool->putCString(resultItemItemBuff, true);
                resultItemArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultItemItemCStr);
            // END SERIALIZE: int generic
            }
        // END SERIALIZE: std::list<int> template
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListListString") {   //  **************** templListListString *****************

        /// std::list< std::list<std::string> > templListListString(const std::list< std::list<std::string> >& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListListString");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list< std::list<std::string> > arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            arg.push_back(std::list<std::string>());
            std::list<std::string>& argItem = arg.back();
        // DESERIALIZE: std::list<std::string> template
            NGREST_ASSERT_NULL(argChild->node);
            NGREST_ASSERT(argChild->node->type == ::ngrest::NodeType::Array, "Array node expected");
            // count = 1 / list / argItem / argItem / static_cast<const ::ngrest::Array*>(argChild->node)
            for (const ::ngrest::LinkedNode* argItemChild = static_cast<const ::ngrest::Array*>(argChild->node)->firstChild; argItemChild; argItemChild = argItemChild->nextSibling) {
                argItem.push_back(std::string());
                std::string& argItemItem = argItem.back();
            // DESERIALIZE: std::string string
                ::ngrest::ObjectModelUtils::getValue(argItemChild->node, argItemItem);
            // END DESERIALIZE: std::string string
            }
        // END DESERIALIZE: std::list<std::string> template
        }
/// ######### deserialize request end ###########

        const std::list< std::list<std::string> >& result = service->templListListString(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        resultNode->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : std::list<std::string> template
        // count = 1
            ::ngrest::Array* resultItemArray = context->pool->alloc< ::ngrest::Array>();
            resultArrayItem->node = resultItemArray;
            ::ngrest::LinkedNode* resultItemArrayItemLast = nullptr;
            for (const auto& resultItemItem : it) {
                ::ngrest::LinkedNode* resultItemArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
                if (resultItemArrayItemLast == nullptr) {
                    resultItemArray->firstChild = resultItemArrayItem;
                } else {
                    resultItemArrayItemLast->nextSibling = resultItemArrayItem;
                }
                resultItemArrayItemLast = resultItemArrayItem;
            // SERIALIZE : std::string string
                resultItemArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, resultItemItem.c_str());
            // END SERIALIZE: std::string string
            }
        // END SERIALIZE: std::list<std::string> template
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListListStruct") {   //  **************** templListListStruct *****************

        /// std::list< std::list< ::ngrest::Test > > templListListStruct(const std::list< std::list<Test> >& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListListStruct");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list< std::list< ::ngrest::Test > > arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            arg.push_back(std::list< ::ngrest::Test >());
            std::list< ::ngrest::Test >& argItem = arg.back();
        // DESERIALIZE: std::list< ::ngrest::Test > template
            NGREST_ASSERT_NULL(argChild->node);
            NGREST_ASSERT(argChild->node->type == ::ngrest::NodeType::Array, "Array node expected");
            // count = 1 / list / argItem / argItem / static_cast<const ::ngrest::Array*>(argChild->node)
            for (const ::ngrest::LinkedNode* argItemChild = static_cast<const ::ngrest::Array*>(argChild->node)->firstChild; argItemChild; argItemChild = argItemChild->nextSibling) {
                argItem.push_back(::ngrest::Test());
                ::ngrest::Test& argItemItem = argItem.back();
            // DESERIALIZE: ::ngrest::Test struct
                ::ngrest::TestSerializer::deserialize(argItemChild->node, argItemItem);
            // END DESERIALIZE: ::ngrest::Test struct
            }
        // END DESERIALIZE: std::list< ::ngrest::Test > template
        }
/// ######### deserialize request end ###########

        const std::list< std::list< ::ngrest::Test > >& result = service->templListListStruct(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        resultNode->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : std::list< ::ngrest::Test > template
        // count = 1
            ::ngrest::Array* resultItemArray = context->pool->alloc< ::ngrest::Array>();
            resultArrayItem->node = resultItemArray;
            ::ngrest::LinkedNode* resultItemArrayItemLast = nullptr;
            for (const auto& resultItemItem : it) {
                ::ngrest::LinkedNode* resultItemArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
                if (resultItemArrayItemLast == nullptr) {
                    resultItemArray->firstChild = resultItemArrayItem;
                } else {
                    resultItemArrayItemLast->nextSibling = resultItemArrayItem;
                }
                resultItemArrayItemLast = resultItemArrayItem;
            // SERIALIZE : ::ngrest::Test struct
                resultItemArrayItem->node = context->pool->alloc< ::ngrest::Object>();
                ::ngrest::TestSerializer::serialize(context, resultItemItem, resultItemArrayItem->node);
            // END SERIALIZE: ::ngrest::Test struct
            }
        // END SERIALIZE: std::list< ::ngrest::Test > template
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListListTypedef") {   //  **************** templListListTypedef *****************

        /// std::list< std::list< ::ngrest::TestTypedef > > templListListTypedef(const std::list< std::list< ::ngrest::TestTypedef > >& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListListTypedef");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list< std::list< ::ngrest::TestTypedef > > arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            arg.push_back(std::list< ::ngrest::TestTypedef >());
            std::list< ::ngrest::TestTypedef >& argItem = arg.back();
        // DESERIALIZE: std::list< ::ngrest::TestTypedef > template
            NGREST_ASSERT_NULL(argChild->node);
            NGREST_ASSERT(argChild->node->type == ::ngrest::NodeType::Array, "Array node expected");
            // count = 1 / list / argItem / argItem / static_cast<const ::ngrest::Array*>(argChild->node)
            for (const ::ngrest::LinkedNode* argItemChild = static_cast<const ::ngrest::Array*>(argChild->node)->firstChild; argItemChild; argItemChild = argItemChild->nextSibling) {
                argItem.push_back(::ngrest::TestTypedef());
                ::ngrest::TestTypedef& argItemItem = argItem.back();
            // DESERIALIZE: ::ngrest::TestTypedef typedef
                ::ngrest::TestTypedefSerializer::deserialize(argItemChild->node, argItemItem);
            // END DESERIALIZE: ::ngrest::TestTypedef typedef
            }
        // END DESERIALIZE: std::list< ::ngrest::TestTypedef > template
        }
/// ######### deserialize request end ###########

        const std::list< std::list< ::ngrest::TestTypedef > >& result = service->templListListTypedef(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        resultNode->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : std::list< ::ngrest::TestTypedef > template
        // count = 1
            ::ngrest::Array* resultItemArray = context->pool->alloc< ::ngrest::Array>();
            resultArrayItem->node = resultItemArray;
            ::ngrest::LinkedNode* resultItemArrayItemLast = nullptr;
            for (const auto& resultItemItem : it) {
                ::ngrest::LinkedNode* resultItemArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
                if (resultItemArrayItemLast == nullptr) {
                    resultItemArray->firstChild = resultItemArrayItem;
                } else {
                    resultItemArrayItemLast->nextSibling = resultItemArrayItem;
                }
                resultItemArrayItemLast = resultItemArrayItem;
            // SERIALIZE : ::ngrest::TestTypedef typedef
                resultItemArrayItem->node = context->pool->alloc< ::ngrest::Object>();
                ::ngrest::TestTypedefSerializer::serialize(context, resultItemItem, resultItemArrayItem->node);
            // END SERIALIZE: ::ngrest::TestTypedef typedef
            }
        // END SERIALIZE: std::list< ::ngrest::TestTypedef > template
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListListList") {   //  **************** templListListList *****************

        /// std::list< std::list< std::list<int> > > templListListList(const std::list< std::list< std::list<int> > >& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListListList");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list< std::list< std::list<int> > > arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            arg.push_back(std::list< std::list<int> >());
            std::list< std::list<int> >& argItem = arg.back();
        // DESERIALIZE: std::list< std::list<int> > template
            NGREST_ASSERT_NULL(argChild->node);
            NGREST_ASSERT(argChild->node->type == ::ngrest::NodeType::Array, "Array node expected");
            // count = 1 / list / argItem / argItem / static_cast<const ::ngrest::Array*>(argChild->node)
            for (const ::ngrest::LinkedNode* argItemChild = static_cast<const ::ngrest::Array*>(argChild->node)->firstChild; argItemChild; argItemChild = argItemChild->nextSibling) {
                argItem.push_back(std::list<int>());
                std::list<int>& argItemItem = argItem.back();
            // DESERIALIZE: std::list<int> template
                NGREST_ASSERT_NULL(argItemChild->node);
                NGREST_ASSERT(argItemChild->node->type == ::ngrest::NodeType::Array, "Array node expected");
                // count = 1 / list / argItemItem / argItemItem / static_cast<const ::ngrest::Array*>(argItemChild->node)
                for (const ::ngrest::LinkedNode* argItemItemChild = static_cast<const ::ngrest::Array*>(argItemChild->node)->firstChild; argItemItemChild; argItemItemChild = argItemItemChild->nextSibling) {
                    int argItemItemItem;
                // DESERIALIZE: int generic
                    ::ngrest::ObjectModelUtils::getValue(argItemItemChild->node, argItemItemItem);
                // END DESERIALIZE: int generic
                    argItemItem.push_back(argItemItemItem);
                }
            // END DESERIALIZE: std::list<int> template
            }
        // END DESERIALIZE: std::list< std::list<int> > template
        }
/// ######### deserialize request end ###########

        const std::list< std::list< std::list<int> > >& result = service->templListListList(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        resultNode->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : std::list< std::list<int> > template
        // count = 1
            ::ngrest::Array* resultItemArray = context->pool->alloc< ::ngrest::Array>();
            resultArrayItem->node = resultItemArray;
            ::ngrest::LinkedNode* resultItemArrayItemLast = nullptr;
            for (const auto& resultItemItem : it) {
                ::ngrest::LinkedNode* resultItemArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
                if (resultItemArrayItemLast == nullptr) {
                    resultItemArray->firstChild = resultItemArrayItem;
                } else {
                    resultItemArrayItemLast->nextSibling = resultItemArrayItem;
                }
                resultItemArrayItemLast = resultItemArrayItem;
            // SERIALIZE : std::list<int> template
            // count = 1
                ::ngrest::Array* resultItemItemArray = context->pool->alloc< ::ngrest::Array>();
                resultItemArrayItem->node = resultItemItemArray;
                ::ngrest::LinkedNode* resultItemItemArrayItemLast = nullptr;
                for (const auto& resultItemItemItem : resultItemItem) {
                    ::ngrest::LinkedNode* resultItemItemArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
                    if (resultItemItemArrayItemLast == nullptr) {
                        resultItemItemArray->firstChild = resultItemItemArrayItem;
                    } else {
                        resultItemItemArrayItemLast->nextSibling = resultItemItemArrayItem;
                    }
                    resultItemItemArrayItemLast = resultItemItemArrayItem;
                // SERIALIZE : int generic
                    char resultItemItemItemBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
                    NGREST_ASSERT(::ngrest::toCString(resultItemItemItem, resultItemItemItemBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
                    const char* resultItemItemItemCStr = context->pool->putCString(resultItemItemItemBuff, true);
                    resultItemItemArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultItemItemItemCStr);
                // END SERIALIZE: int generic
                }
            // END SERIALIZE: std::list<int> template
            }
        // END SERIALIZE: std::list< std::list<int> > template
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templMapInt") {   //  **************** templMapInt *****************

        /// std::map<int, std::string> templMapInt(const std::map<int, std::string>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templMapInt");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::map<int, std::string> arg;

        // count = 2
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Object);
        for (const ::ngrest::NamedNode* argChild = static_cast<const ::ngrest::Object*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            NGREST_ASSERT_NULL(argChild->name);
            int argKey;
            NGREST_ASSERT(::ngrest::fromCString(argChild->name, argKey), "Cannot deserialize key of arg");

            std::string& argValue = arg[argKey];
        // DESERIALIZE: std::string string
            ::ngrest::ObjectModelUtils::getValue(argChild->node, argValue);
        // END DESERIALIZE: std::string string
        }
/// ######### deserialize request end ###########

        const std::map<int, std::string>& result = service->templMapInt(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 2
        ::ngrest::Object* resultObj = context->pool->alloc< ::ngrest::Object>();
        resultNode->node = resultObj;
        ::ngrest::NamedNode* lastResultObjItem = nullptr;
        for (const auto& it : result) {
        char resultBuffItem[NGREST_NUM_TO_STR_BUFF_SIZE];
        NGREST_ASSERT(::ngrest::toCString(it.first, resultBuffItem, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize result for TestService/templMapInt");
        const char* CStr = context->pool->putCString(resultBuffItem, true);
            ::ngrest::NamedNode* resultObjItem = context->pool->alloc< ::ngrest::NamedNode>(CStr);
            if (lastResultObjItem == nullptr) {
                resultObj->firstChild = resultObjItem;
            } else {
                lastResultObjItem->nextSibling = resultObjItem;
            }
            lastResultObjItem = resultObjItem;

        // SERIALIZE : std::string string
            resultObjItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, it.second.c_str());
        // END SERIALIZE: std::string string
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templMapEnum") {   //  **************** templMapEnum *****************

        /// std::map< ::ngrest::ValType, std::string > templMapEnum(const std::map<ValType, std::string>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templMapEnum");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::map< ::ngrest::ValType, std::string > arg;

        // count = 2
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Object);
        for (const ::ngrest::NamedNode* argChild = static_cast<const ::ngrest::Object*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            NGREST_ASSERT_NULL(argChild->name);
            ::ngrest::ValType argKey = ::ngrest::ValTypeSerializer::fromCString(argChild->name);

            std::string& argValue = arg[argKey];
        // DESERIALIZE: std::string string
            ::ngrest::ObjectModelUtils::getValue(argChild->node, argValue);
        // END DESERIALIZE: std::string string
        }
/// ######### deserialize request end ###########

        const std::map< ::ngrest::ValType, std::string >& result = service->templMapEnum(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 2
        ::ngrest::Object* resultObj = context->pool->alloc< ::ngrest::Object>();
        resultNode->node = resultObj;
        ::ngrest::NamedNode* lastResultObjItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::NamedNode* resultObjItem = context->pool->alloc< ::ngrest::NamedNode>(::ngrest::ValTypeSerializer::toCString(it.first));
            if (lastResultObjItem == nullptr) {
                resultObj->firstChild = resultObjItem;
            } else {
                lastResultObjItem->nextSibling = resultObjItem;
            }
            lastResultObjItem = resultObjItem;

        // SERIALIZE : std::string string
            resultObjItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, it.second.c_str());
        // END SERIALIZE: std::string string
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templMapStr") {   //  **************** templMapStr *****************

        /// std::map<std::string, std::string> templMapStr(const std::map<std::string, std::string>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templMapStr");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::map<std::string, std::string> arg;

        // count = 2
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Object);
        for (const ::ngrest::NamedNode* argChild = static_cast<const ::ngrest::Object*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            NGREST_ASSERT_NULL(argChild->name);
        // inline argChild->name

            std::string& argValue = arg[argChild->name];
        // DESERIALIZE: std::string string
            ::ngrest::ObjectModelUtils::getValue(argChild->node, argValue);
        // END DESERIALIZE: std::string string
        }
/// ######### deserialize request end ###########

        const std::map<std::string, std::string>& result = service->templMapStr(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 2
        ::ngrest::Object* resultObj = context->pool->alloc< ::ngrest::Object>();
        resultNode->node = resultObj;
        ::ngrest::NamedNode* lastResultObjItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::NamedNode* resultObjItem = context->pool->alloc< ::ngrest::NamedNode>(it.first.c_str());
            if (lastResultObjItem == nullptr) {
                resultObj->firstChild = resultObjItem;
            } else {
                lastResultObjItem->nextSibling = resultObjItem;
            }
            lastResultObjItem = resultObjItem;

        // SERIALIZE : std::string string
            resultObjItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, it.second.c_str());
        // END SERIALIZE: std::string string
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templMapStrMapStrStr") {   //  **************** templMapStrMapStrStr *****************

        /// std::map< std::string, std::map<std::string, std::string> > templMapStrMapStrStr(const std::map< std::string, std::map<std::string, std::string> >& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templMapStrMapStrStr");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::map< std::string, std::map<std::string, std::string> > arg;

        // count = 2
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Object);
        for (const ::ngrest::NamedNode* argChild = static_cast<const ::ngrest::Object*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            NGREST_ASSERT_NULL(argChild->name);
        // inline argChild->name

            std::map<std::string, std::string>& argValue = arg[argChild->name];
        // DESERIALIZE: std::map<std::string, std::string> template
            NGREST_ASSERT_NULL(argChild->node);
            NGREST_ASSERT(argChild->node->type == ::ngrest::NodeType::Object, "Object node expected");
            // count = 2 / map / argValue / argValue / static_cast<const ::ngrest::Object*>(argChild->node)
            for (const ::ngrest::NamedNode* argValueChild = static_cast<const ::ngrest::Object*>(argChild->node)->firstChild; argValueChild; argValueChild = argValueChild->nextSibling) {
                NGREST_ASSERT_NULL(argValueChild->name);
                // deserialize key

                std::string& argValueValue = argValue[argValueChild->name];
                // deserialize value
            // DESERIALIZE: std::string string
                ::ngrest::ObjectModelUtils::getValue(argValueChild->node, argValueValue);
            // END DESERIALIZE: std::string string
            } // for(NamedNode...
        // END DESERIALIZE: std::map<std::string, std::string> template
        }
/// ######### deserialize request end ###########

        const std::map< std::string, std::map<std::string, std::string> >& result = service->templMapStrMapStrStr(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 2
        ::ngrest::Object* resultObj = context->pool->alloc< ::ngrest::Object>();
        resultNode->node = resultObj;
        ::ngrest::NamedNode* lastResultObjItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::NamedNode* resultObjItem = context->pool->alloc< ::ngrest::NamedNode>(it.first.c_str());
            if (lastResultObjItem == nullptr) {
                resultObj->firstChild = resultObjItem;
            } else {
                lastResultObjItem->nextSibling = resultObjItem;
            }
            lastResultObjItem = resultObjItem;

        // SERIALIZE : std::map<std::string, std::string> template
        // count = 2
            ::ngrest::Object* resultItemObj = context->pool->alloc< ::ngrest::Object>();
            resultObjItem->node = resultItemObj;
            ::ngrest::NamedNode* resultItemObjItemLast = nullptr;
            for (const auto& resultItemItem : it.second) {
                ::ngrest::NamedNode* resultItemObjItem = context->pool->alloc< ::ngrest::NamedNode>(resultItemItem.first.c_str());
                if (resultItemObjItemLast == nullptr) {
                    resultItemObj->firstChild = resultItemObjItem;
                } else {
                    resultItemObjItemLast->nextSibling = resultItemObjItem;
                }
                resultItemObjItemLast = resultItemObjItem;

            // SERIALIZE : std::string string
                resultItemObjItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, resultItemItem.second.c_str());
            // END SERIALIZE: std::string string
            }
        // END SERIALIZE: std::map<std::string, std::string> template
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "testTypedef") {   //  **************** testTypedef *****************

        /// ::ngrest::StringMap testTypedef(const ::ngrest::StringMap& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/testTypedef");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::StringMap arg;

        const ::ngrest::NamedNode* argObj = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg");
        ::ngrest::StringMapSerializer::deserialize(argObj->node, arg);
/// ######### deserialize request end ###########

        const ::ngrest::StringMap& result = service->testTypedef(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::StringMapSerializer::serialize(context, result, resultNode->node);

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "testEnum") {   //  **************** testEnum *****************

        /// ::ngrest::ValType testEnum(ValType arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/testEnum");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::ValType arg;

        arg = ::ngrest::ValTypeSerializer::fromCString(::ngrest::ObjectModelUtils::getChildValue(request, "arg"));
/// ######### deserialize request end ###########

        ::ngrest::ValType result = service->testEnum(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, ::ngrest::ValTypeSerializer::toCString(result));

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "testNestedEnum") {   //  **************** testNestedEnum *****************

        /// ::ngrest::Test::TestEnum testNestedEnum(Test::TestEnum arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/testNestedEnum");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::Test::TestEnum arg;

        arg = ::ngrest::TestSerializer::TestEnumSerializer::fromCString(::ngrest::ObjectModelUtils::getChildValue(request, "arg"));
/// ######### deserialize request end ###########

        ::ngrest::Test::TestEnum result = service->testNestedEnum(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, ::ngrest::TestSerializer::TestEnumSerializer::toCString(result));

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "testNestedStruct") {   //  **************** testNestedStruct *****************

        /// ::ngrest::Test::Nested testNestedStruct(Test::Nested arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/testNestedStruct");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::Test::Nested arg;

        const ::ngrest::NamedNode* argObj = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Object);
        ::ngrest::TestSerializer::NestedSerializer::deserialize(argObj->node, arg);
/// ######### deserialize request end ###########

        const ::ngrest::Test::Nested& result = service->testNestedStruct(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::TestSerializer::NestedSerializer::serialize(context, result, resultNode->node);

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrInt") {   //  **************** ptrInt *****************

        /// ngrest::Nullable<int> ptrInt(ngrest::Nullable<int> arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/ptrInt");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ngrest::Nullable<int> arg;

        // count = 1
        const ::ngrest::NamedNode* namedNodearg = request->findChildByName("arg");
        if (namedNodearg != nullptr && namedNodearg->node != nullptr) {
        // DESERIALIZE: int generic
            ::ngrest::ObjectModelUtils::getValue(namedNodearg->node, arg.get());
        // END DESERIALIZE: int generic
        }
/// ######### deserialize request end ###########

        const ngrest::Nullable<int>& result = service->ptrInt(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        if (result.isValid()) {
        // SERIALIZE : int generic
            char resultBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
            NGREST_ASSERT(::ngrest::toCString((*result), resultBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
            const char* resultCStr = context->pool->putCString(resultBuff, true);
            resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultCStr);
        // END SERIALIZE: int generic
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrIntConst") {   //  **************** ptrIntConst *****************

        /// ngrest::Nullable<int> ptrIntConst(const ngrest::Nullable<int>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/ptrIntConst");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ngrest::Nullable<int> arg;

        // count = 1
        const ::ngrest::NamedNode* namedNodearg = request->findChildByName("arg");
        if (namedNodearg != nullptr && namedNodearg->node != nullptr) {
        // DESERIALIZE: int generic
            ::ngrest::ObjectModelUtils::getValue(namedNodearg->node, arg.get());
        // END DESERIALIZE: int generic
        }
/// ######### deserialize request end ###########

        const ngrest::Nullable<int>& result = service->ptrIntConst(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        if (result.isValid()) {
        // SERIALIZE : int generic
            char resultBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
            NGREST_ASSERT(::ngrest::toCString((*result), resultBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
            const char* resultCStr = context->pool->putCString(resultBuff, true);
            resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultCStr);
        // END SERIALIZE: int generic
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrString") {   //  **************** ptrString *****************

        /// ngrest::Nullable<std::string> ptrString(ngrest::Nullable<std::string> arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/ptrString");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ngrest::Nullable<std::string> arg;

        // count = 1
        const ::ngrest::NamedNode* namedNodearg = request->findChildByName("arg");
        if (namedNodearg != nullptr && namedNodearg->node != nullptr) {
        // DESERIALIZE: std::string string
            ::ngrest::ObjectModelUtils::getValue(namedNodearg->node, arg.get());
        // END DESERIALIZE: std::string string
        }
/// ######### deserialize request end ###########

        const ngrest::Nullable<std::string>& result = service->ptrString(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        if (result.isValid()) {
        // SERIALIZE : std::string string
            resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, (*result).c_str());
        // END SERIALIZE: std::string string
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrEnum") {   //  **************** ptrEnum *****************

        /// ngrest::Nullable< ::ngrest::ValType > ptrEnum(ngrest::Nullable<ValType> arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/ptrEnum");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ngrest::Nullable< ::ngrest::ValType > arg;

        // count = 1
        const ::ngrest::NamedNode* namedNodearg = request->findChildByName("arg");
        if (namedNodearg != nullptr && namedNodearg->node != nullptr) {
        // DESERIALIZE: ::ngrest::ValType enum
            arg.get() = ::ngrest::ValTypeSerializer::fromCString(::ngrest::ObjectModelUtils::getValue(namedNodearg->node));
        // END DESERIALIZE: ::ngrest::ValType enum
        }
/// ######### deserialize request end ###########

        const ngrest::Nullable< ::ngrest::ValType >& result = service->ptrEnum(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        if (result.isValid()) {
        // SERIALIZE : ::ngrest::ValType enum
            resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, ::ngrest::ValTypeSerializer::toCString((*result)));
        // END SERIALIZE: ::ngrest::ValType enum
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrStruct") {   //  **************** ptrStruct *****************

        /// ngrest::Nullable< ::ngrest::Test > ptrStruct(ngrest::Nullable<Test> arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/ptrStruct");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ngrest::Nullable< ::ngrest::Test > arg;

        // count = 1
        const ::ngrest::NamedNode* namedNodearg = request->findChildByName("arg");
        if (namedNodearg != nullptr && namedNodearg->node != nullptr) {
            ::ngrest::Test& argNullable = arg.get();
        // DESERIALIZE: ::ngrest::Test struct
            ::ngrest::TestSerializer::deserialize(namedNodearg->node, argNullable);
        // END DESERIALIZE: ::ngrest::Test struct
        }
/// ######### deserialize request end ###########

        const ngrest::Nullable< ::ngrest::Test >& result = service->ptrStruct(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        if (result.isValid()) {
        // SERIALIZE : ::ngrest::Test struct
            resultNode->node = context->pool->alloc< ::ngrest::Object>();
            ::ngrest::TestSerializer::serialize(context, (*result), resultNode->node);
        // END SERIALIZE: ::ngrest::Test struct
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrStructList") {   //  **************** ptrStructList *****************

        /// ngrest::Nullable< std::list< ::ngrest::Test > > ptrStructList(ngrest::Nullable< std::list<Test> > arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/ptrStructList");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ngrest::Nullable< std::list< ::ngrest::Test > > arg;

        // count = 1
        const ::ngrest::NamedNode* namedNodearg = request->findChildByName("arg");
        if (namedNodearg != nullptr && namedNodearg->node != nullptr) {
            std::list< ::ngrest::Test >& argNullable = arg.get();
        // DESERIALIZE: std::list< ::ngrest::Test > template
            NGREST_ASSERT_NULL(namedNodearg->node);
            NGREST_ASSERT(namedNodearg->node->type == ::ngrest::NodeType::Array, "Array node expected");
            // count = 1 / list / argNullable / arg / static_cast<const ::ngrest::Array*>(namedNodearg->node)
            for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(namedNodearg->node)->firstChild; argChild; argChild = argChild->nextSibling) {
                argNullable.push_back(::ngrest::Test());
                ::ngrest::Test& argItem = argNullable.back();
            // DESERIALIZE: ::ngrest::Test struct
                ::ngrest::TestSerializer::deserialize(argChild->node, argItem);
            // END DESERIALIZE: ::ngrest::Test struct
            }
        // END DESERIALIZE: std::list< ::ngrest::Test > template
        }
/// ######### deserialize request end ###########

        const ngrest::Nullable< std::list< ::ngrest::Test > >& result = service->ptrStructList(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        if (result.isValid()) {
        // SERIALIZE : std::list< ::ngrest::Test > template
        // count = 1
            ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
            resultNode->node = resultArray;
            ::ngrest::LinkedNode* resultArrayItemLast = nullptr;
            for (const auto& resultItem : (*result)) {
                ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
                if (resultArrayItemLast == nullptr) {
                    resultArray->firstChild = resultArrayItem;
                } else {
                    resultArrayItemLast->nextSibling = resultArrayItem;
                }
                resultArrayItemLast = resultArrayItem;
            // SERIALIZE : ::ngrest::Test struct
                resultArrayItem->node = context->pool->alloc< ::ngrest::Object>();
                ::ngrest::TestSerializer::serialize(context, resultItem, resultArrayItem->node);
            // END SERIALIZE: ::ngrest::Test struct
            }
        // END SERIALIZE: std::list< ::ngrest::Test > template
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrNull") {   //  **************** ptrNull *****************

        /// ::ngrest::TestPtr ptrNull();

        const ::ngrest::TestPtr& result = service->ptrNull();

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::TestPtrSerializer::serialize(context, result, resultNode->node);

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrNotNull") {   //  **************** ptrNotNull *****************

        /// ::ngrest::TestPtr ptrNotNull();

        const ::ngrest::TestPtr& result = service->ptrNotNull();

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::TestPtrSerializer::serialize(context, result, resultNode->node);

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrTest") {   //  **************** ptrTest *****************

        /// ::ngrest::TestPtr ptrTest(const TestPtr& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/ptrTest");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::TestPtr arg;

        const ::ngrest::NamedNode* argObj = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Object);
        ::ngrest::TestPtrSerializer::deserialize(argObj->node, arg);
/// ######### deserialize request end ###########

        const ::ngrest::TestPtr& result = service->ptrTest(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::TestPtrSerializer::serialize(context, result, resultNode->node);

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrTestNull") {   //  **************** ptrTestNull *****************

        /// ngrest::Nullable< ::ngrest::TestPtr > ptrTestNull(const ngrest::Nullable<TestPtr>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/ptrTestNull");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ngrest::Nullable< ::ngrest::TestPtr > arg;

        // count = 1
        const ::ngrest::NamedNode* namedNodearg = request->findChildByName("arg");
        if (namedNodearg != nullptr && namedNodearg->node != nullptr) {
            ::ngrest::TestPtr& argNullable = arg.get();
        // DESERIALIZE: ::ngrest::TestPtr struct
            ::ngrest::TestPtrSerializer::deserialize(namedNodearg->node, argNullable);
        // END DESERIALIZE: ::ngrest::TestPtr struct
        }
/// ######### deserialize request end ###########

        const ngrest::Nullable< ::ngrest::TestPtr >& result = service->ptrTestNull(arg);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

// count = 1
        if (result.isValid()) {
        // SERIALIZE : ::ngrest::TestPtr struct
            resultNode->node = context->pool->alloc< ::ngrest::Object>();
            ::ngrest::TestPtrSerializer::serialize(context, (*result), resultNode->node);
        // END SERIALIZE: ::ngrest::TestPtr struct
        }

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "getInline") {   //  **************** getInline *****************

        /// bool getInline();

        bool result = service->getInline();

/// ######### serialize response ###########


        context->response->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Boolean, result ? "true" : "false");
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "echoSyncInline") {   //  **************** echoSyncInline *****************

        /// std::string echoSyncInline(const std::string& value);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/echoSyncInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::string value;

        ::ngrest::ObjectModelUtils::getChildValue(request, "value", value);
/// ######### deserialize request end ###########

        const std::string& result = service->echoSyncInline(value);

/// ######### serialize response ###########


        context->response->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, result.c_str());
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "addInline") {   //  **************** addInline *****************

        /// int addInline(int a, int b);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/addInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        int a;
        int b;

        ::ngrest::ObjectModelUtils::getChildValue(request, "a", a);
        ::ngrest::ObjectModelUtils::getChildValue(request, "b", b);
/// ######### deserialize request end ###########

        int result = service->addInline(a, b);

/// ######### serialize response ###########


        char resultBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
        NGREST_ASSERT(::ngrest::toCString(result, resultBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize result for TestService/addInline");
        const char* resultCStr = context->pool->putCString(resultBuff, true);
        context->response->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultCStr);
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "notifyInline") {   //  **************** notifyInline *****************

        /// void notifyInline();

        service->notifyInline();

        context->callback->success();
    } else if (operation->name == "testInline") {   //  **************** testInline *****************

        /// ::ngrest::Test testInline(const Test& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/testInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::Test arg;

        const ::ngrest::NamedNode* argObj = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Object);
        ::ngrest::TestSerializer::deserialize(argObj->node, arg);
/// ######### deserialize request end ###########

        const ::ngrest::Test& result = service->testInline(arg);

/// ######### serialize response ###########


        context->response->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::TestSerializer::serialize(context, result, context->response->node);
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListStrInline") {   //  **************** templListStrInline *****************

        /// std::list<std::string> templListStrInline(const std::list<std::string>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListStrInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list<std::string> arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            arg.push_back(std::string());
            std::string& argItem = arg.back();
        // DESERIALIZE: std::string string
            ::ngrest::ObjectModelUtils::getValue(argChild->node, argItem);
        // END DESERIALIZE: std::string string
        }
/// ######### deserialize request end ###########

        const std::list<std::string>& result = service->templListStrInline(arg);

/// ######### serialize response ###########


// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        context->response->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : std::string string
            resultArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, it.c_str());
        // END SERIALIZE: std::string string
        }
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templVectorInline") {   //  **************** templVectorInline *****************

        /// std::vector<int> templVectorInline(const std::vector<int>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templVectorInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::vector<int> arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            int argItem;
        // DESERIALIZE: int generic
            ::ngrest::ObjectModelUtils::getValue(argChild->node, argItem);
        // END DESERIALIZE: int generic
            arg.push_back(argItem);
        }
/// ######### deserialize request end ###########

        const std::vector<int>& result = service->templVectorInline(arg);

/// ######### serialize response ###########


// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        context->response->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : int generic
            char resultItemBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
            NGREST_ASSERT(::ngrest::toCString(it, resultItemBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
            const char* resultItemCStr = context->pool->putCString(resultItemBuff, true);
            resultArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultItemCStr);
        // END SERIALIZE: int generic
        }
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListOfTypedefListInline") {   //  **************** templListOfTypedefListInline *****************

        /// ::ngrest::StringList templListOfTypedefListInline(const ::ngrest::StringList& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListOfTypedefListInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::StringList arg;

        const ::ngrest::NamedNode* argObj = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg");
        ::ngrest::StringListSerializer::deserialize(argObj->node, arg);
/// ######### deserialize request end ###########

        const ::ngrest::StringList& result = service->templListOfTypedefListInline(arg);

/// ######### serialize response ###########


        context->response->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::StringListSerializer::serialize(context, result, context->response->node);
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templListListInline") {   //  **************** templListListInline *****************

        /// std::list< std::list<int> > templListListInline(const std::list< std::list<int> >& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templListListInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::list< std::list<int> > arg;

        // count = 1
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Array);
        for (const ::ngrest::LinkedNode* argChild = static_cast<const ::ngrest::Array*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            arg.push_back(std::list<int>());
            std::list<int>& argItem = arg.back();
        // DESERIALIZE: std::list<int> template
            NGREST_ASSERT_NULL(argChild->node);
            NGREST_ASSERT(argChild->node->type == ::ngrest::NodeType::Array, "Array node expected");
            // count = 1 / list / argItem / argItem / static_cast<const ::ngrest::Array*>(argChild->node)
            for (const ::ngrest::LinkedNode* argItemChild = static_cast<const ::ngrest::Array*>(argChild->node)->firstChild; argItemChild; argItemChild = argItemChild->nextSibling) {
                int argItemItem;
            // DESERIALIZE: int generic
                ::ngrest::ObjectModelUtils::getValue(argItemChild->node, argItemItem);
            // END DESERIALIZE: int generic
                argItem.push_back(argItemItem);
            }
        // END DESERIALIZE: std::list<int> template
        }
/// ######### deserialize request end ###########

        const std::list< std::list<int> >& result = service->templListListInline(arg);

/// ######### serialize response ###########


// count = 1
        ::ngrest::Array* resultArray = context->pool->alloc< ::ngrest::Array>();
        context->response->node = resultArray;
        ::ngrest::LinkedNode* lastResultArrayItem = nullptr;
        for (const auto& it : result) {
            ::ngrest::LinkedNode* resultArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
            if (lastResultArrayItem == nullptr) {
                resultArray->firstChild = resultArrayItem;
            } else {
                lastResultArrayItem->nextSibling = resultArrayItem;
            }
            lastResultArrayItem = resultArrayItem;
        // SERIALIZE : std::list<int> template
        // count = 1
            ::ngrest::Array* resultItemArray = context->pool->alloc< ::ngrest::Array>();
            resultArrayItem->node = resultItemArray;
            ::ngrest::LinkedNode* resultItemArrayItemLast = nullptr;
            for (const auto& resultItemItem : it) {
                ::ngrest::LinkedNode* resultItemArrayItem = context->pool->alloc< ::ngrest::LinkedNode>();
                if (resultItemArrayItemLast == nullptr) {
                    resultItemArray->firstChild = resultItemArrayItem;
                } else {
                    resultItemArrayItemLast->nextSibling = resultItemArrayItem;
                }
                resultItemArrayItemLast = resultItemArrayItem;
            // SERIALIZE : int generic
                char resultItemItemBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
                NGREST_ASSERT(::ngrest::toCString(resultItemItem, resultItemItemBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
                const char* resultItemItemCStr = context->pool->putCString(resultItemItemBuff, true);
                resultItemArrayItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultItemItemCStr);
            // END SERIALIZE: int generic
            }
        // END SERIALIZE: std::list<int> template
        }
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "templMapIntInline") {   //  **************** templMapIntInline *****************

        /// std::map<int, std::string> templMapIntInline(const std::map<int, std::string>& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/templMapIntInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::map<int, std::string> arg;

        // count = 2
        const ::ngrest::NamedNode* argNode = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Object);
        for (const ::ngrest::NamedNode* argChild = static_cast<const ::ngrest::Object*>(argNode->node)->firstChild; argChild; argChild = argChild->nextSibling) {
            NGREST_ASSERT_NULL(argChild->name);
            int argKey;
            NGREST_ASSERT(::ngrest::fromCString(argChild->name, argKey), "Cannot deserialize key of arg");

            std::string& argValue = arg[argKey];
        // DESERIALIZE: std::string string
            ::ngrest::ObjectModelUtils::getValue(argChild->node, argValue);
        // END DESERIALIZE: std::string string
        }
/// ######### deserialize request end ###########

        const std::map<int, std::string>& result = service->templMapIntInline(arg);

/// ######### serialize response ###########


// count = 2
        ::ngrest::Object* resultObj = context->pool->alloc< ::ngrest::Object>();
        context->response->node = resultObj;
        ::ngrest::NamedNode* lastResultObjItem = nullptr;
        for (const auto& it : result) {
        char resultBuffItem[NGREST_NUM_TO_STR_BUFF_SIZE];
        NGREST_ASSERT(::ngrest::toCString(it.first, resultBuffItem, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize result for TestService/templMapIntInline");
        const char* CStr = context->pool->putCString(resultBuffItem, true);
            ::ngrest::NamedNode* resultObjItem = context->pool->alloc< ::ngrest::NamedNode>(CStr);
            if (lastResultObjItem == nullptr) {
                resultObj->firstChild = resultObjItem;
            } else {
                lastResultObjItem->nextSibling = resultObjItem;
            }
            lastResultObjItem = resultObjItem;

        // SERIALIZE : std::string string
            resultObjItem->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, it.second.c_str());
        // END SERIALIZE: std::string string
        }
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "testTypedefInline") {   //  **************** testTypedefInline *****************

        /// ::ngrest::StringMap testTypedefInline(const ::ngrest::StringMap& arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/testTypedefInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::StringMap arg;

        const ::ngrest::NamedNode* argObj = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg");
        ::ngrest::StringMapSerializer::deserialize(argObj->node, arg);
/// ######### deserialize request end ###########

        const ::ngrest::StringMap& result = service->testTypedefInline(arg);

/// ######### serialize response ###########


        context->response->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::StringMapSerializer::serialize(context, result, context->response->node);
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "testEnumInline") {   //  **************** testEnumInline *****************

        /// ::ngrest::ValType testEnumInline(ValType arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/testEnumInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::ValType arg;

        arg = ::ngrest::ValTypeSerializer::fromCString(::ngrest::ObjectModelUtils::getChildValue(request, "arg"));
/// ######### deserialize request end ###########

        ::ngrest::ValType result = service->testEnumInline(arg);

/// ######### serialize response ###########


        context->response->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, ::ngrest::ValTypeSerializer::toCString(result));
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "testNestedEnumInline") {   //  **************** testNestedEnumInline *****************

        /// ::ngrest::Test::TestEnum testNestedEnumInline(Test::TestEnum arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/testNestedEnumInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::Test::TestEnum arg;

        arg = ::ngrest::TestSerializer::TestEnumSerializer::fromCString(::ngrest::ObjectModelUtils::getChildValue(request, "arg"));
/// ######### deserialize request end ###########

        ::ngrest::Test::TestEnum result = service->testNestedEnumInline(arg);

/// ######### serialize response ###########


        context->response->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, ::ngrest::TestSerializer::TestEnumSerializer::toCString(result));
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "testNestedStructInline") {   //  **************** testNestedStructInline *****************

        /// ::ngrest::Test::Nested testNestedStructInline(Test::Nested arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/testNestedStructInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ::ngrest::Test::Nested arg;

        const ::ngrest::NamedNode* argObj = ::ngrest::ObjectModelUtils::getNamedChild(request, "arg", ::ngrest::NodeType::Object);
        ::ngrest::TestSerializer::NestedSerializer::deserialize(argObj->node, arg);
/// ######### deserialize request end ###########

        const ::ngrest::Test::Nested& result = service->testNestedStructInline(arg);

/// ######### serialize response ###########


        context->response->node = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::TestSerializer::NestedSerializer::serialize(context, result, context->response->node);
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "ptrIntInline") {   //  **************** ptrIntInline *****************

        /// ngrest::Nullable<int> ptrIntInline(ngrest::Nullable<int> arg);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/ptrIntInline");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        ngrest::Nullable<int> arg;

        // count = 1
        const ::ngrest::NamedNode* namedNodearg = request->findChildByName("arg");
        if (namedNodearg != nullptr && namedNodearg->node != nullptr) {
        // DESERIALIZE: int generic
            ::ngrest::ObjectModelUtils::getValue(namedNodearg->node, arg.get());
        // END DESERIALIZE: int generic
        }
/// ######### deserialize request end ###########

        const ngrest::Nullable<int>& result = service->ptrIntInline(arg);

/// ######### serialize response ###########


// count = 1
        if (result.isValid()) {
        // SERIALIZE : int generic
            char resultBuff[NGREST_NUM_TO_STR_BUFF_SIZE];
            NGREST_ASSERT(::ngrest::toCString((*result), resultBuff, NGREST_NUM_TO_STR_BUFF_SIZE), "Failed to serialize int");
            const char* resultCStr = context->pool->putCString(resultBuff, true);
            context->response->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::Number, resultCStr);
        // END SERIALIZE: int generic
        }
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "echo") {   //  **************** echo *****************

        /// std::string echo(const std::string& value);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/echo");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::string value;

        ::ngrest::ObjectModelUtils::getChildValue(request, "value", value);
/// ######### deserialize request end ###########

        const std::string& result = service->echo(value);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, result.c_str());

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else if (operation->name == "echoPost") {   //  **************** echoPost *****************

        /// std::string echoPost(const std::string& value);

/// ######### deserialize request ###########
        NGREST_ASSERT(context->request->node, "Request expected for ngrest.TestService/echoPost");
        NGREST_ASSERT_PARAM(context->request->node->type == ::ngrest::NodeType::Object);

        const ::ngrest::Object* request = static_cast<const ::ngrest::Object*>(context->request->node);

        std::string value;

        ::ngrest::ObjectModelUtils::getChildValue(request, "value", value);
/// ######### deserialize request end ###########

        const std::string& result = service->echoPost(value);

/// ######### serialize response ###########

        ::ngrest::Object* responseNode = context->pool->alloc< ::ngrest::Object>();
        ::ngrest::NamedNode* resultNode = context->pool->alloc< ::ngrest::NamedNode>("result");
        responseNode->firstChild = resultNode;

        resultNode->node = context->pool->alloc< ::ngrest::Value>(::ngrest::ValueType::String, result.c_str());

        context->response->node = responseNode;
/// ######### serialize response end ###########

        context->callback->success();
    } else {
        NGREST_THROW_ASSERT("No operation " + operation->name + " found in service TestService");
    }
}

const ::ngrest::ServiceDescription* TestServiceWrapper::getDescription() const
{
    static ::ngrest::ServiceDescription description = {
        "ngrest.TestService", // name
        "ngrest/test", // location
        R"()", // description
        R"()", // details
        {
            {
                "get",             // name
                "", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {

                },
                ::ngrest::ParameterDescription::Type::Boolean, false
            },
            {
                "echoSync",             // name
                "echoSync?value={value}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"value", ::ngrest::ParameterDescription::Type::String, false}
                },
                ::ngrest::ParameterDescription::Type::String, false
            },
            {
                "echoASync",             // name
                "echoASync?value={value}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                true,
                R"()", // description
                R"()", // details
                {
                    {"value", ::ngrest::ParameterDescription::Type::String, false}
                },
                ::ngrest::ParameterDescription::Type::Undefined, false
            },
            {
                "largeResponse",             // name
                "", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {

                },
                ::ngrest::ParameterDescription::Type::String, false
            },
            {
                "add",             // name
                "add?a={a}&b={b}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"a", ::ngrest::ParameterDescription::Type::Number, false},
                    {"b", ::ngrest::ParameterDescription::Type::Number, false}
                },
                ::ngrest::ParameterDescription::Type::Number, false
            },
            {
                "set",             // name
                "set?val={val}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"val", ::ngrest::ParameterDescription::Type::Boolean, false}
                },
                ::ngrest::ParameterDescription::Type::Undefined, false
            },
            {
                "notify",             // name
                "", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {

                },
                ::ngrest::ParameterDescription::Type::Undefined, false
            },
            {
                "test",             // name
                "theTest", // location
                static_cast<int>(::ngrest::HttpMethod::PUT),
                "PUT",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, false}
                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "templListStr",             // name
                "templListStr?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templList",             // name
                "templList?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templVector",             // name
                "templVector?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templListOfStruct",             // name
                "templListOfStruct?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templListOfTypedef",             // name
                "templListOfTypedef?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templListOfTypedefList",             // name
                "templListOfTypedefList?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Any, false}
                },
                ::ngrest::ParameterDescription::Type::Any, false
            },
            {
                "templListList",             // name
                "templListList?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templListListString",             // name
                "templListListString?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templListListStruct",             // name
                "templListListStruct?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templListListTypedef",             // name
                "templListListTypedef?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templListListList",             // name
                "templListListList?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templMapInt",             // name
                "templMapInt?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, false}
                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "templMapEnum",             // name
                "templMapEnum?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, false}
                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "templMapStr",             // name
                "templMapStr?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, false}
                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "templMapStrMapStrStr",             // name
                "templMapStrMapStrStr?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, false}
                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "testTypedef",             // name
                "testTypedef?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Any, false}
                },
                ::ngrest::ParameterDescription::Type::Any, false
            },
            {
                "testEnum",             // name
                "testEnum?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::String, false}
                },
                ::ngrest::ParameterDescription::Type::String, false
            },
            {
                "testNestedEnum",             // name
                "testNestedEnum?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::String, false}
                },
                ::ngrest::ParameterDescription::Type::String, false
            },
            {
                "testNestedStruct",             // name
                "testNestedStruct?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, false}
                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "ptrInt",             // name
                "ptrInt?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Number, true}
                },
                ::ngrest::ParameterDescription::Type::Number, true
            },
            {
                "ptrIntConst",             // name
                "ptrIntConst?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Number, true}
                },
                ::ngrest::ParameterDescription::Type::Number, true
            },
            {
                "ptrString",             // name
                "ptrString?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::String, true}
                },
                ::ngrest::ParameterDescription::Type::String, true
            },
            {
                "ptrEnum",             // name
                "ptrEnum?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::String, true}
                },
                ::ngrest::ParameterDescription::Type::String, true
            },
            {
                "ptrStruct",             // name
                "ptrStruct?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, true}
                },
                ::ngrest::ParameterDescription::Type::Object, true
            },
            {
                "ptrStructList",             // name
                "ptrStructList?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, true}
                },
                ::ngrest::ParameterDescription::Type::Array, true
            },
            {
                "ptrNull",             // name
                "", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {

                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "ptrNotNull",             // name
                "", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {

                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "ptrTest",             // name
                "ptrTest?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, false}
                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "ptrTestNull",             // name
                "ptrTestNull?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, true}
                },
                ::ngrest::ParameterDescription::Type::Object, true
            },
            {
                "getInline",             // name
                "", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {

                },
                ::ngrest::ParameterDescription::Type::Boolean, false
            },
            {
                "echoSyncInline",             // name
                "echoSyncInline?value={value}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"value", ::ngrest::ParameterDescription::Type::String, false}
                },
                ::ngrest::ParameterDescription::Type::String, false
            },
            {
                "addInline",             // name
                "addInline?a={a}&b={b}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"a", ::ngrest::ParameterDescription::Type::Number, false},
                    {"b", ::ngrest::ParameterDescription::Type::Number, false}
                },
                ::ngrest::ParameterDescription::Type::Number, false
            },
            {
                "notifyInline",             // name
                "", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {

                },
                ::ngrest::ParameterDescription::Type::Undefined, false
            },
            {
                "testInline",             // name
                "theTestInline", // location
                static_cast<int>(::ngrest::HttpMethod::PUT),
                "PUT",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, false}
                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "templListStrInline",             // name
                "templListStrInline?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templVectorInline",             // name
                "templVectorInline?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templListOfTypedefListInline",             // name
                "templListOfTypedefListInline?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Any, false}
                },
                ::ngrest::ParameterDescription::Type::Any, false
            },
            {
                "templListListInline",             // name
                "templListListInline?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Array, false}
                },
                ::ngrest::ParameterDescription::Type::Array, false
            },
            {
                "templMapIntInline",             // name
                "templMapIntInline?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, false}
                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "testTypedefInline",             // name
                "testTypedefInline?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Any, false}
                },
                ::ngrest::ParameterDescription::Type::Any, false
            },
            {
                "testEnumInline",             // name
                "testEnumInline?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::String, false}
                },
                ::ngrest::ParameterDescription::Type::String, false
            },
            {
                "testNestedEnumInline",             // name
                "testNestedEnumInline?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::String, false}
                },
                ::ngrest::ParameterDescription::Type::String, false
            },
            {
                "testNestedStructInline",             // name
                "testNestedStructInline?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Object, false}
                },
                ::ngrest::ParameterDescription::Type::Object, false
            },
            {
                "ptrIntInline",             // name
                "ptrIntInline?arg={arg}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"arg", ::ngrest::ParameterDescription::Type::Number, true}
                },
                ::ngrest::ParameterDescription::Type::Number, true
            },
            {
                "echo",             // name
                "echo?value={value}", // location
                static_cast<int>(::ngrest::HttpMethod::GET),
                "GET",
                false,
                R"()", // description
                R"()", // details
                {
                    {"value", ::ngrest::ParameterDescription::Type::String, false}
                },
                ::ngrest::ParameterDescription::Type::String, false
            },
            {
                "echoPost",             // name
                "echo", // location
                static_cast<int>(::ngrest::HttpMethod::POST),
                "POST",
                false,
                R"()", // description
                R"()", // details
                {
                    {"value", ::ngrest::ParameterDescription::Type::String, false}
                },
                ::ngrest::ParameterDescription::Type::String, false
            }
        }
    };

    return &description;
}


}

